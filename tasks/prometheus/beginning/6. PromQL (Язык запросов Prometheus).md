## PromQL (Язык запросов Prometheus)

**PromQL (Prometheus Query Language)** — это декларативный язык запросов, разработанный специально для анализа и обработки временных рядов данных в системе мониторинга **Prometheus**. Он позволяет выполнять сложные операции над метриками, такими как фильтрация, агрегация, расчет производных показателей и сравнение данных в реальном времени.

### **Пример использования PromQL с Grafana**
```mermaid
sequenceDiagram
    participant App as "Приложение (App)"
    participant Exporter as "Экспортер"
    participant Prometheus as "Prometheus Server"
    participant Grafana as "Grafana"

    Exporter->>App: Вызов API приложения или чтение системных файлов/логов
    App-->>Exporter: Предоставление данных через API, файлы или библиотеки

    loop Каждые N секунд
        Prometheus->>Exporter: HTTP GET (Pull метрик)
        Exporter-->>Prometheus: HTTP 200 OK + Текстовые метрики
    end

    note over Grafana,Prometheus: Использование PromQL для запросов
    Grafana->>Prometheus: HTTP GET (Запрос с PromQL-запросом)
    Prometheus-->>Grafana: HTTP 200 OK + Результаты запроса в формате JSON
```

**Описание:**  
- Prometheus собирает метрики.
- Grafana использует PromQL для составления сложных запросов к Prometheus.
- Prometheus возвращает результаты запроса в формате JSON для визуализации.

---

### Язык предоставляет инструменты для выполнения следующих задач:

1. **Выборка данных**: Выбор конкретных временных рядов на основе их имени и меток (labels).
2. **Фильтрация**: Ограничение результатов с использованием логических и сравнительных операторов.
3. **Агрегация**: Объединение множества временных рядов в один или несколько с помощью функций агрегации (например, `sum`, `avg`, `min`, `max`).
4. **Вычисление производных показателей**: Расчет скорости изменений (`rate`), увеличения (`increase`), процентилей и других метрик на основе исторических данных.
5. **Операции над временными интервалами**: Анализ данных за заданные периоды времени с использованием временных диапазонов (range vectors).

---

### **Основные концепции PromQL**
1. **Метрика**: Это название измеряемого показателя (например, `http_requests_total`).
2. **Лейблы (метки)**: Дополнительные атрибуты метрики в формате `ключ=значение` (например, `{method="GET", handler="/api"}`).
3. **Временные ряды**: Prometheus хранит данные как последовательности значений во времени для каждой уникальной комбинации метрики и меток.
4. **Операторы**: Используются для сравнения, фильтрации или агрегации данных.

---

### **Простые примеры запросов**

#### 1. **Получить значение конкретной метрики**
Если вы хотите увидеть все значения метрики `http_requests_total`:
```promql
http_requests_total
```
- **Что делает запрос?** Возвращает все временные ряды для метрики `http_requests_total`.

---

#### 2. **Фильтрация по лейблам**
Если вам нужны только запросы с методом `GET`:
```promql
http_requests_total{method="GET"}
```
- **Что делает запрос?** Фильтрует метрику `http_requests_total`, оставляя только те временные ряды, где лейбл `method` равен `"GET"`.

---

#### 3. **Сравнение значений**
Чтобы найти все временные ряды, где значение больше 100:
```promql
http_requests_total > 100
```
- **Что делает запрос?** Возвращает только те временные ряды, где текущее значение метрики больше 100.

---

#### 4. **Агрегация данных**
Если вам нужно посчитать общее количество HTTP-запросов:
```promql
sum(http_requests_total)
```
- **Что делает запрос?** Складывает значения всех временных рядов для метрики `http_requests_total`.

Если вы хотите посчитать сумму только для запросов с определенным методом:
```promql
sum(http_requests_total{method="POST"})
```

---

#### 5. **Группировка по лейблам**
Чтобы посчитать сумму запросов для каждого обработчика (`handler`):
```promql
sum by (handler) (http_requests_total)
```
- **Что делает запрос?** Группирует результаты по лейблу `handler` и считает сумму для каждого значения этого лейбла.

---

#### 6. **Расчет скорости изменений**
Чтобы узнать скорость поступления новых запросов за последние 5 минут:
```promql
rate(http_requests_total[5m])
```
- **Что делает запрос?** Вычисляет среднюю скорость увеличения метрики `http_requests_total` за последние 5 минут.

---

#### 7. **Процент ошибок**
Если у вас есть метрика `http_request_errors_total` (количество ошибок), вы можете рассчитать процент ошибок:
```promql
(sum(rate(http_request_errors_total[5m])) / sum(rate(http_requests_total[5m]))) * 100
```
- **Что делает запрос?** Сначала вычисляет скорость ошибок и общую скорость запросов за последние 5 минут, затем находит их отношение и умножает на 100 для получения процента.

---

### **Краткий словарь терминов**
- **Метрика**: Измеряемый показатель (например, `http_requests_total`).
- **Метка**: Атрибут метрики в формате `ключ=значение` (например, `{method="GET"}`).
- **Временной ряд**: Последовательность значений метрики со временем для конкретной комбинации меток.
- **Агрегация**: Объединение нескольких значений в одно (например, сумма или среднее).
- **Rate**: Скорость изменения метрики за указанный период.

---

### **Практический совет**
Начните с простых запросов, таких как `http_requests_total` или `node_cpu_seconds_total`, и постепенно добавляйте фильтры, агрегацию и расчеты. Prometheus предоставляет визуальную подсказку (auto-complete) в интерфейсе, которая поможет вам составлять запросы.

## Cправочник при написании запросов в Prometheus.   

   Таблицы с основными функциями агрегирования и запросов в Prometheus, структурированные по категориям:

   #### Таблица 1: Основные агрегирующие функции
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `sum()` | Сумма значений | `sum(http_requests_total)` |
   | `avg()` | Среднее значение | `avg(http_request_duration_seconds)` |
   | `max()` | Максимальное значение | `max(node_memory_MemTotal)` |
   | `min()` | Минимальное значение | `min(node_cpu_seconds_total)` |
   | `stddev()` | Стандартное отклонение | `stddev(http_request_duration_seconds)` |
   | `stdvar()` | Дисперсия | `stdvar(http_request_duration_seconds)` |
   | `count()` | Количество элементов | `count(http_requests_total)` |
   
   ---
   
   #### Таблица 2: Функции для работы со временем
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `rate()` | Скорость изменения за интервал времени | `rate(http_requests_total[5m])` |
   | `irate()` | Скорость изменения между последними двумя точками | `irate(http_requests_total[5m])` |
   | `delta()` | Разница между первым и последним значением | `delta(node_filesystem_free[1h])` |
   | `increase()` | Увеличение счетчика за интервал времени | `increase(http_requests_total[1h])` |
   | `time()` | Текущее время в секундах с Unix epoch | `time()` |
   
   ---
   
   #### Таблица 3: Функции для распределений и квантилей
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `histogram_quantile(φ, ...)` | Расчет квантиля из histogram | `histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))` |
   | `quantile_over_time(φ, ...)` | Расчет квантиля за временной интервал | `quantile_over_time(0.95, http_request_duration_seconds[5m])` |
   | `avg_over_time(...)` | Среднее значение за временной интервал | `avg_over_time(http_request_duration_seconds[5m])` |
   | `max_over_time(...)` | Максимальное значение за временной интервал | `max_over_time(http_request_duration_seconds[5m])` |
   | `min_over_time(...)` | Минимальное значение за временной интервал | `min_over_time(http_request_duration_seconds[5m])` |
   
   ---
   
   #### Таблица 4: Функции для группировки и фильтрации
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `by` | Группировка по указанным меткам | `sum(http_requests_total) by (method)` |
   | `without` | Исключение указанных меток из группировки | `sum(http_requests_total) without (instance)` |
   | `label_replace()` | Замена меток | `label_replace(http_requests_total, "new_label", "$1", "old_label", "(.*)")` |
   | `label_join()` | Объединение меток | `label_join(http_requests_total, "combined", "_", "label1", "label2")` |
   
   ---
   
   #### Таблица 5: Математические и логические функции
   
   | Функция | Описание | Пример использования |
   |---------|----------|----------------------|
   | `abs()` | Абсолютное значение | `abs(http_request_duration_seconds)` |
   | `ceil()` | Округление вверх | `ceil(http_request_duration_seconds)` |
   | `floor()` | Округление вниз | `floor(http_request_duration_seconds)` |
   | `round()` | Округление до ближайшего целого | `round(http_request_duration_seconds)` |
   | `clamp_min()` | Ограничение минимального значения | `clamp_min(http_request_duration_seconds, 0)` |
   | `clamp_max()` | Ограничение максимального значения | `clamp_max(http_request_duration_seconds, 10)` |
   
   ---
   
   #### Таблица 6: Логические операторы
   
   | Оператор | Описание | Пример использования |
   |----------|----------|----------------------|
   | `==` | Равно | `http_requests_total == 100` |
   | `!=` | Не равно | `http_requests_total != 0` |
   | `>` | Больше | `http_request_duration_seconds > 1` |
   | `<` | Меньше | `http_request_duration_seconds < 0.5` |
   | `>=` | Больше или равно | `http_requests_total >= 100` |
   | `<=` | Меньше или равно | `http_request_duration_seconds <= 2` |
   
   ---
   
   #### Таблица 7: Встроенные константы и функции
   
   | Константа/Функция | Описание | Пример использования |
   |--------------------|----------|----------------------|
   | `up` | Состояние доступности таргета (1 - доступен, 0 - недоступен) | `up{job="api"}` |
   | `time()` | Текущее время в секундах с Unix epoch | `time()` |
   | `scalar()` | Преобразование в скалярное значение | `scalar(sum(http_requests_total))` |
   | `vector()` | Преобразование в вектор | `vector(1)` |
   
   ---
   
   #### Комментарий к таблицам:
   
   1. **Агрегирующие функции** (`sum`, `avg`, `max`, `min`) используются для объединения данных.
   2. **Функции для работы со временем** (`rate`, `irate`, `delta`, `increase`) помогают анализировать динамику изменений.
   3. **Функции для распределений и квантилей** (`histogram_quantile`, `quantile_over_time`) применяются для анализа гистограмм и summary метрик.
   4. **Группировка и фильтрация** (`by`, `without`, `label_replace`) позволяют управлять метками и группировать данные.
   5. **Математические и логические функции** обеспечивают возможность выполнять различные преобразования и сравнения.
   

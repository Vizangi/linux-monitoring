# **Observability (Наблюдаемость)**

* **Что это простыми словами?** Представьте, что у вас есть сложный механизм (например, автомобиль с множеством датчиков). Мониторинг — это когда вы смотрите на приборную панель: скорость, уровень топлива, температура двигателя (заранее выбранные показатели). Observability — это возможность подключиться к *любому* датчику в автомобиле (даже к тем, о которых вы не думали заранее), чтобы понять, почему он вдруг начал издавать странный звук или почему расход топлива увеличился необоснованно.
* **Официальное определение:** Observability — это свойство системы (или способность), которое позволяет вам понять её внутреннее состояние, *просто* анализируя данные, которые она генерирует извне (телеметрию). Ключевое отличие от мониторинга в том, что для Observability вам *не нужно заранее знать* все возможные причины сбоев или все вопросы, которые вы захотите задать системе в будущем. Вы можете исследовать *неизвестные* проблемы.
* **Зачем нужна?** В современных распределенных системах (микросервисы, облачные технологии) очень сложно понять, что происходит "внутри", когда возникает проблема. Одна пользовательская транзакция может проходить через десятки сервисов. Observability дает инструменты и данные, чтобы "увидеть", что именно происходит, где затык, кто виноват, даже если такая проблема возникла впервые. Это критически важно для быстрого поиска и устранения ошибок (MTTR - Mean Time To Recovery), понимания производительности и оптимизации.

**Три основных столпа Observability:**

Это три типа данных, которые система должна генерировать и которые вы должны собирать и анализировать, чтобы достичь Observability.

1.  **Метрики (Metrics):**
    * **Что это?** Это агрегированные, числовые данные, собранные за определенный период времени. Думайте о них как о "графиках" или "счетчиках".
    * **Примеры:**
        * Загрузка CPU (в процентах).
        * Объем используемой памяти (в гигабайтах или процентах).
        * Количество запросов к сервису в секунду (RPS - Requests Per Second).
        * Среднее время ответа сервиса (Latency).
        * Количество ошибок определенного типа за минуту.
        * Размер очереди сообщений.
    * **Для чего используются?** Идеально подходят для мониторинга общего состояния системы, создания дашбордов, отслеживания трендов производительности во времени, настройки алертов (уведомлений) при превышении пороговых значений. Метрики эффективны для хранения и анализа больших объемов данных за длительный период.

2.  **Логи (Logs):**
    * **Что это?** Это дискретные, временные записи событий, произошедших в системе или приложении в конкретный момент времени. Это как "журнал" действий.
    * **Примеры:**
        * Пользователь с ID 123 вошел в систему.
        * Произошла ошибка при обработке платежа для транзакции XYZ: "Недостаточно средств".
        * Сервис А успешно отправил данные сервису Б.
        * Запущена фоновая задача "Отправка отчетов".
    * **Для чего используются?** Логи бесценны для отладки конкретных инцидентов. Когда метрики показывают, что что-то не так (например, вырос процент ошибок), вы идете в логи, чтобы понять *почему* это произошло. Логи дают детальный контекст события. Сбор, централизация и анализ логов (с помощью инструментов типа ELK Stack, Splunk и т.д.) позволяют быстро найти нужные записи среди терабайтов данных.

3.  **Трейсы (Traces):**
    * **Что это?** Это представление одного запроса или транзакции, проходящей через несколько компонентов распределенной системы (например, через несколько микросервисов). Каждый шаг запроса в отдельном сервисе называется "спан" (span), и все спаны, относящиеся к одному запросу, объединяются в трейс (trace).
    * **Примеры:**
        * Пользователь нажимает кнопку "Купить".
        * Фронтенд отправляет запрос сервису заказов.
        * Сервис заказов запрашивает данные пользователя у сервиса профилей.
        * Сервис заказов запрашивает списание средств у платежного сервиса.
        * Платежный сервис взаимодействует с внешним банком.
        * Платежный сервис возвращает результат сервису заказов.
        * Сервис заказов обновляет статус заказа и отправляет уведомление сервису уведомлений.
    * **Для чего используются?** Трейсы критически важны в мире микросервисов. Они позволяют визуализировать путь запроса, понять зависимости между сервисами, выявить, на каком этапе произошла задержка или ошибка, и определить, какой именно сервис является "бутылочным горлышком". Без трейсов очень сложно отладить проблему, которая затрагивает несколько сервисов.

**Чем отличается от мониторинга?**

* **Мониторинг:**
    * Фокусируется на *известных* вещах и *предопределенных* вопросах ("Находится ли загрузка CPU выше 80%?", "Есть ли ошибки 5xx ответов?", "Работает ли сервис?").
    * Отвечает на вопрос "Что не так?".
    * Обычно основан на агрегированных метриках и заранее определенных логах/событиях.
    * Больше похож на "проверку пульса" системы по заданному списку.
* **Observability:**
    * Предоставляет *возможность* задавать *любые* вопросы о состоянии системы *ретроспективно*, даже о тех сценариях, о которых вы не думали заранее.
    * Отвечает на вопрос "Почему это не так?" и "Что именно происходит?".
    * Опирается на все три типа данных (метрики, логи, трейсы), позволяя связывать их друг с другом для глубокого анализа.
    * Больше похож на "хирургическое исследование" системы с доступом ко всей необходимой информации.

**Примеры инструментов Observability:**

Это инструменты, которые помогают собирать, обрабатывать, хранить и анализировать данные телеметрии (метрики, логи, трейсы).

* **OpenTelemetry (OTel):**
    * **Что это?** Это открытый, нейтральный к вендорам стандарт и набор инструментов (API, SDK, коллекторы) для инструментирования приложений и сбора данных телеметрии.
    * **Зачем нужен?** Позволяет разработчикам единообразно собирать метрики, логи и трейсы из своих приложений, не привязываясь к конкретному инструменту анализа (Datadog, Prometheus, Jaeger и т.д.). Вы инструментируете код один раз с помощью OpenTelemetry, а затем можете отправлять данные в любую совместимую backend-систему. Это золотой стандарт для инструментирования в Observability.
* **Jaeger:**
    * **Что это?** Популярная открытая система распределенного трейсинга.
    * **Что делает?** Собирает, хранит, ищет и визуализирует данные трейсов. Помогает увидеть путь запроса через микросервисы и анализировать спаны.
* **Prometheus:**
    * **Что это?** Ведущая открытая система мониторинга и оповещения, ориентированная на метрики.
    * **Что делает?** Собирает метрики (по модели pull), хранит их в time-series базе данных и предоставляет мощный язык запросов (PromQL) для анализа и создания алертов. Часто используется в связке с Grafana для визуализации дашбордов. (Хотя Prometheus в первую очередь инструмент мониторинга, сбор метрик является основой для Observability).
* **ELK Stack (Elasticsearch, Logstash, Kibana) / EFK Stack:**
    * **Что это?** Набор открытых инструментов для сбора, обработки, хранения и анализа логов.
    * **Что делают?** Logstash/Fluentd собирают логи из разных источников, Elasticsearch хранит их и обеспечивает быстрый поиск, а Kibana предоставляет удобный веб-интерфейс для визуализации и анализа логов.
* **Datadog, New Relic, Dynatrace и т.д.:**
    * **Что это?** Комплексные коммерческие платформы Observability.
    * **Что делают?** Предоставляют "всё в одном": сбор, хранение и анализ метрик, логов и трейсов в едином интерфейсе. Часто включают функции Application Performance Monitoring (APM), мониторинга инфраструктуры, мониторинга пользовательского опыта и т.д. Удобны, но могут быть дорогими.

**Вывод:**

* **Мониторинг** — это проверка здоровья системы по заранее известным показателям. Это *необходимый* фундамент.
* **Observability** — это способность глубоко исследовать систему, когда что-то пошло не так или работает неоптимально, даже если проблема совершенно новая и неожиданная. Это требует сбора и связывания всех трех типов данных: метрик, логов и трейсов.
* В современных сложных системах Observability является развитием и дополнением мониторинга. Лучшие практики предполагают **инструментирование** ваших приложений (с помощью OpenTelemetry, например) для генерации богатых данных телеметрии, а затем использование **инструментов** (как открытых, так и коммерческих) для сбора, анализа и визуализации этих данных для целей как мониторинга (известные проблемы), так и Observability (неизвестные проблемы).
